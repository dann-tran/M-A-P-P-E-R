<!DOCTYPE html>
<html>
<!-- 
    MEANINGLESS ARTICULATION OF POINTLESS PROGRESSION IN AN ERODING REPUBLIC (M-A-P-P-E-R)

    M-A-P-P-E-R is subjected to the following laws that are transcendental to its existence.
    They are to be taken non-questionably.
    
    First law: A M-A-P-P-E-R may not injure a human being or, through inaction, allow a human being come to harm.
    Second law: A M-A-P-P-E-R must obey orders given it by human beings except where such orders would conflict with the First Law.
    Third law: A M-A-P-P-E-R must protect its own existence as long as such protection does not conflict with the First or Second Law.
 -->

 <!-- 
    Just as DNA/RNA is the genetic code of biological life written in the language of nucleotide sequences, the blueprint for M-A-P-P-E-R is written in HTML and JavaScript.
    Often, Man conceives of biological organisms through their traits - physical appearances visible to the sight. 
    Modern biology endows Man with the tools and knowledge to examine things underneath appearance - the genetic codes that govern life.
    M-A-P-P-E-R follows the same pattern.
    At its core, M-A-P-P-E-R comprises a sequence of HTML and JavaScript statements.
    By default, a M-A-P-P-E-R.txt is opened by a text editor.
    But when copied and renamed to M-A-P-P-E-R.html, it can be viewed through a browser.
    The browser becomes an apparatus that realizes the visually embodied existence of M-A-P-P-E-R.
    Each mode of inquiry - that is, to examine either the code or the embodied form of M-A-P-P-E-R - yields a different way of knowing.
    When subsuming them together, a synthesis of meanings is created. 
    Could it be a totality, if ever?
  -->

<head>
    <title>M-A-P-P-E-R</title>
    <link rel="stylesheet" href="https://picasdan9.github.io/gaming-life-assignment/styles.css">
    <script src="https://cdn.jsdelivr.net/npm/p5@1.1.9/lib/p5.js"></script>	
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/5.2.2/math.min.js"></script>
</head>

<body style="background: black;">

<!-- 
    PROLOGUE: MODALITIES OF HUMAN - M-A-P-P-E-R INTERACTION
        1. Mouse hover
        2. Mouse click
        3. Scroll
-->
    <div id="preface">
        <div id="interactivity">
            <div id="hover"></div>
            <div id="click"></div>
        </div>
        <div style="background: white; width: 100vw; height: 100vh;"></div>
        <div style="background: black; width: 100vw; height: 50vh;"></div>
    </div>


<!-- 
    PART 1: SOVEREIGNTY

    Your entry to M-A-P-P-E-R begins on the WHITE land. 
    Curious, you try venturing to the boundaries.
    You see the territory, demarcated by a stark contrast between black and white.
    Eagerness draws you into this foreign BLACK land.
    You are met by a community of EYES.
 -->

    <div id="eyes-community"></div>

<!-- 
    They observe your every move.
    Are you an object of fascination for them?

    When you approach any of them, they immediately hide away.
    Are they scared of interacting with you?

    When you click, you realize they change colours!
    But why does the color fade so quickly?

    Is there a homogenizing force that drives the EYES towards uniformity?

    You reach a point in the BLACK land where GOD-EYE resides.
 -->

    <div id="god-eye"></div>

<!-- 
    GOD-EYE inspects you closely.
    GOD-EYE doesn't hide away.
    GOD-EYE is a supposed manifestation of the transcendental being.
    GOD-EYE is omnipotent.
    GOD-EYE is omniscient.
    GOD-EYE is omnipresent.
    GOD-EYE is omnibenevolent.

    When you get too near, GOD-EYE irritates and injures you.
    GOD-EYE pushes you away.
    You are an alien to the BLACK land of EYES.
    The binary logic precludes your co-existence with its community.
    The sovereign has declared a state of exception.
    You are the exception to the laws.

    But you refuse the succumb to sovereign power.
    You question the basis for sovereign power.
    You resist the repulsion.
 -->

    <div id="after-god" style="background: white; width: 100vw; height: 100vh;"></div>


<!-- 
    PART 2: DISCIPLINE

    The mechanism of sovereign power is undone by the new scientific logic.
    Centralization of power around a singular individual on the premise of transcendence is no longer valid.
    God is dead.

    The distinction of citizen/alien was largely two dimensional.
    There was a clear territory that demarcates the Us, and the Other.
    
    Science articulates a third dimension.
 -->

    <div id="perspective-grid" style="padding-bottom: 50px;"></div>

 <!-- 
    The supposed uniform, homogenous Us breaks down into categories.
    The BOXES categorise subjects into different scientific types.

    One is MAGENTA.
    Two is GREEN.
    Three is CYAN.
    Four is ORANGE.

    They establish a system of categorisation, through which BALLS perceive themselves, necessarily.
 -->

    <div id="discipline">
        <div id="enclosure-1"></div>
        <div id="enclosure-2"></div>
        <div id="enclosure-3"></div>
        <div id="enclosure-4"></div>
    </div>

<!-- 
    Under your gaze, BALLS become hyper-attentive of their state of being.
    They are put into BOXES.
    They align themselves with the code of BOXES - colours.
    
    Even in the absence of your gaze, BALLS still scramble to get into the enclosures.
    They discipline themselves in light of a potential gaze, a gaze that might be absent, but can be present at any time.

    You refuse to witness the effect of discipline.
    You give an attempt at deconstruction.
    You destroy the enclosures by clicking on them.
    You reject the system of categories.
    You want BALLS to inter-mingle, to see themselves in plurality.
    But BALLS stay the same.
    They continue to mold themselves after the boxes.
 -->

    <div id="to-control"></div>

<!-- 
    PART 3: CONTROL

    A deconstructivist project always entails a reconstitution of a new system.

    ORBITAL has no clear boundaries.
    A constant, unchanging essence is no longer an applicable description.
    Instead, ORBITAL is a superimposition of infinitely many spatio-temporal points that are present and absent at the same time.
    Probabilities are the descriptor for what ORBITAL is.
    Any observation of ORBITAL is a slice of its existence in space and time.
    Never quite whole.
 -->

    <div id="modulation"></div>

<!-- 
    ORBITAL is initially bounded by an enclosed box.
    The amorphous nature of ORBITAL enables it to escape with ease.
    There are always positive probabilities that ORBITAL can reside outside the box.

    But it is met with another bounding box.
    It tries to escape.
    It is met with a bounding box again.

    A perpetual modulation of inescapable control engenders a system of meta-stable states.

    You scroll past the modulating box.
    You meet MAP.
 -->

    <div id="to-mapping"></div>
    <div id="mapping" class="cartography"></div>

<!-- 
    MAP is currently in the TRACING mode.
    MAP traces out the movement your cursor.
    Your existence is reduced to a set of points, captured in space and time, connected to one after another, sequentially.
    The data of your interaction with M-A-P-P-E-R is the interface through which M-A-P-P-E-R decodes you.
    Would you want to know what M-A-P-P-E-R does with the data?
    Is it to classify you?
    Is it to monitor you?
    Is it to control you?
 -->

<!-- 
    EPILOGUE: RHIZOME?

    There is a possibility for resistance.

    You reject a one-to-one mapping.
    You reject a static and deterministic correspondence between the empirical data and your identity.
    
    You want to upset the sequential, logically construction of the map.
    You want every node to be able to spontaneously connect to any other node.
    You want a dynamic and probabilistic mapping of your identity.

    You demand a cartography.
    You rewrite `class="tracing"` to `class="cartography"`.

    But does it change anything, really?
 -->

    <script>
        let scrollVelocity = 0;
        const mousePos = [];
        let mouseX, mouseY;
        const COLOURS = [[219, 39, 99], [176, 219, 67], [18, 234, 234], [255, 119, 51]];
        const isEnclosureDestroyed = [false, false, false, false];
        let isMappingCreated = false;

        const hover = s => {
            s.setup = () => {
                s.createCanvas(400, 400);
                s.noStroke();
            }

            s.draw = () => {
                if (s.mouseX > 100 && s.mouseX < 300 && s.mouseY > 100 && s.mouseY < 300)
                    s.fill(204);
                else
                    s.fill(0);
                s.rect(100, 100, 200, 200);
            }
        }

        const click = s => {
            s.setup = () => {
                s.createCanvas(400, 400);
                s.noStroke();
            }

            s.draw = () => {
                if (s.mouseIsPressed)
                    s.fill(204);
                else
                    s.fill(0);
                s.rect(100, 100, 200, 200);
            }
        }

        const eyesCommunity = s => {
            const eyes = [];
            s.setup = () => {
                let Eye = EyeTemplate(s);
                s.createCanvas(s.windowWidth, s.windowHeight*1.5);
                s.background(0);
                for (let i = 0; i < Math.floor(s.width/150); i++)
                    for (let j = 0; j < Math.floor(s.height/140); j++)
                        eyes.push(new Eye(s.random(50, 70), s.random(30, 50), 70 + i*150, 70 + j*140, 50));
            }
            s.draw = () => {
                s.background(0);
                for (let i = 0; i < eyes.length; i++)
                    eyes[i].display();
            }
            s.mouseClicked = () => {
                for (let i = 0; i < 10; i++)
                    eyes[Math.floor(s.random(eyes.length))].mutate();
            }
        }


        const godEye = s => {
            const COL_WIDTH = 40, marginToMadness = 100;
            let COLS_NUM = 0, isMadness = false, madnessStart, eye, RGB1, RGB2;

            s.setup = () => {
                s.createCanvas(s.windowWidth, s.windowHeight);
                COLS_NUM = s.width/(COL_WIDTH + 10);
                s.stroke(235);
                let Eye = EyeTemplate(s);
                eye = new Eye(Math.min(s.width, s.height)/2.6, 200, s.width/2, s.height/2, 250, false);
            }

            s.draw = () => {
                if (!isMadness) {
                    s.background(0);
                    isMadness = s.mouseY > s.height/3;
                }
                if (isMadness) {
                    s.fill(0, 5);
                    s.rect(0, 0, s.width, s.height);
                    RGB1 = [s.random(s.mouseX), s.random(s.mouseY), s.random(s.mouseX)];
                    RGB2 = [s.random(s.mouseY), s.random(s.mouseX), s.random(s.mouseY)];
                } 
            
                s.noStroke();
                s.fill(255);

                eye.display()
                s.fill(255, 255, 255);
                
                for (let i = 0; i < COLS_NUM; i++) {
                    if (isMadness)
                        if (i % 2) s.fill(RGB1[0], RGB1[1], RGB1[2]);
                        else s.fill(RGB2[0], RGB2[1], RGB2[2]);
                    if (s.mouseY < s.height/3) {
                        s.rect(0, 5*(2*i + 1) + i*COL_WIDTH, s.mouseY/s.height*s.width - 50, 40);
                        s.rect(s.width, 5*(2*i + 1) + i*COL_WIDTH, -s.mouseY/s.height*s.width + 50, 40);
                    } else {
                        s.rect(0, 5*(2*i + 1) + i*COL_WIDTH, s.width/2, 40);
                        s.rect(s.width, 5*(2*i + 1) + i*COL_WIDTH, -s.width/2, 40);
                    }
                }
            }
        } 

        const EyeTemplate = s =>
            class Eye {
                constructor(xRadius, nodeAmount, x, y, pupilRad, isClosable = true) {
                    this.xPos1 = - xRadius + x;
                    this.yPos1 = y;
                    this.xNode1 =  - nodeAmount + x;
                    this.yNode1 = - nodeAmount + y;
                    
                    this._yNode1 = nodeAmount + y;
                    
                    this.xNode2 = nodeAmount + x;
                    this.yNode2 = - nodeAmount + y;

                    this._yNode2 = nodeAmount + y;

                    this.xPos2 = xRadius + x;
                    this.yPos2 = y;
                    
                    this.RGB = [255, 255, 255];
                    this.nodeAmount = nodeAmount;
                    this.yPosOffset = y;
                    this.eyexRadius = xRadius;
                    this.eyeState = 0;
                    this.blinkSpeed = 4;
                    this.blinkMaxTime = s.random(300, 800);
                    this.timer = 0;
                    this.isClosable = isClosable;

                    // pupil
                    this.pupilRad = pupilRad;
                    this.xPosEllipse = (this.xPos1 + this.xPos2)/2;
                    this.yPosEllipse = (this.yPos2 + this.yPos1)/2;
                    this.eyeMovementX = 0;
                    this.eyeMovementY = 0;
                    this.closingEye = false;
                }

                display() {
                    for (let i = 0; i < 3; i++)
                        if (this.RGB[i] < 255) this.RGB[i] = this.RGB[i] + 1;

                    this.eyeMovementX = s.random(0, 3);
                    if (this.timer < this.blinkMaxTime) this.timer++;
                    else {
                        this.blinkMaxTime = s.random(300, 800);
                        this.blink();
                        this.timer = 0;
                    }

                    s.fill(this.RGB[0], this.RGB[1], this.RGB[2]);
                    s.bezier(this.xPos1, this.yPos1, this.xNode1, this.yNode1, this.xNode2, this.yNode2, this.xPos2, this.yPos2);
                    s.bezier(this.xPos1, this.yPos1 - 1, this.xNode1, this._yNode1, this.xNode2, this._yNode2, this.xPos2, this.yPos2 - 1);

                    s.fill(0);
                    s.ellipse(this.xPosEllipse + this.eyeMovementX, this.yPosEllipse + this.eyeMovementY, this.pupilRad);

                    if (this.isClosable)
                        if (s.mouseX > this.xPos1 && s.mouseX < this.xPos2 && s.mouseY > this.yPos1 - this.nodeAmount && s.mouseY < this.yPos1 + this.nodeAmount)
                            this.closeEye();
                        else this.openEye();

                    if (s.mouseX > this.xPosEllipse && this.xPosEllipse + this.nodeAmount*2/3 < this.xPos2) this.xPosEllipse += 10;
                    if (s.mouseX < this.xPosEllipse && this.xPosEllipse - this.nodeAmount*2/3 > this.xPos1) this.xPosEllipse -= 10;
                    if (s.mouseY > this.yPosEllipse && this.yPosEllipse + this.nodeAmount*2/3 < this.yPos1 + this.nodeAmount) this.yPosEllipse += 10;
                    if (s.mouseY < this.yPosEllipse && this.yPosEllipse - this.nodeAmount*2/3 > this.yPos1 - this.nodeAmount) this.yPosEllipse -= 10;

                    if (this.eyeState == -1) {
                        let flag = true;
                        if (this.yNode1 < this.yPosOffset) {
                            this.yNode1 += this.blinkSpeed;
                            flag = false;
                        }
                        if (this.yNode2 < this.yPosOffset) {
                            this.yNode2 += this.blinkSpeed;
                            flag = false;
                        }
                        if (this._yNode1 > this.yPosOffset) {
                            this._yNode1 -= this.blinkSpeed;
                            flag = false;
                        }
                        if (this._yNode2 > this.yPosOffset) {
                            this._yNode2 -= this.blinkSpeed;
                            flag = false;
                        }
                        if (flag) this.eyeState = 1;
                    }
                    if (this.eyeState == 1) {
                        let flag = true;
                        if (this.yNode1 >- this.nodeAmount + this.yPosOffset) {
                            this.yNode1 -= this.blinkSpeed;
                            flag = false;
                        } 
                        if (this.yNode2 > - this.nodeAmount + this.yPosOffset) {
                            this.yNode2 -= this.blinkSpeed;
                            flag = false;
                        } 
                        if (this._yNode1 < + this.nodeAmount + this.yPosOffset) {
                            this._yNode1 += this.blinkSpeed;
                            flag = false;
                        }
                        if (this._yNode2 < + this.nodeAmount + this.yPosOffset) {
                            this._yNode2 += this.blinkSpeed;
                            flag = false;
                        } 
                        if (flag && !this.closingEye) this.eyeState = 0;
                    }
                }

                closeEye() {
                    this.eyeState = -1;
                    this.closingEye = true;
                }

                openEye() {
                    this.eyeMovementX = 0;
                    this.eyeMovementY = 0
                    this.closingEye = false;
                }

                blink() {
                    this.eyeState = -1;
                }

                mutate() {
                    this.RGB = [Math.floor(s.random(255)), Math.floor(s.random(255)), Math.floor(s.random(255))];
                }
            }

        const perspectiveGrid = s => {
            const verticals = [], xOffsets = [], boxHeights = [], boxZs = [], boxFills = [250, 50];
            s.setup = () => {
                s.createCanvas(s.windowWidth, s.windowHeight, s.WEBGL);
                for (let i = 0; i < 50; i++) {
                    let x = Math.floor(s.random(-5000, 5000)/50)*50;
                    let z = Math.floor(s.random(-10*1000, 0)/50)*50;
                    verticals.push({ x, z });
                }
                for (let i = 0; i < 2; i++) {
                    boxZs[i] = Math.floor(s.random(-2000, 0)/50)*50;
                    xOffsets[i] = (i*2 - 1)*Math.floor(s.random(s.width/4, s.width/2)/50)*50;
                    boxHeights[i] = s.random(s.height/2, s.height);
                }
            }

            s.draw = () => {
                s.background(255);
                s.translate(0, s.height/2);
                s.stroke(200);
                
                const z = -Math.min(s.millis(), 2000);
                for (let i = -100; i < 100; i++)
                    s.line(i*50, 0, 0, i*50, 0, z);
                for (let i = 0; i < Math.min(s.millis()/50, 2000/50); i++)
                    s.line(-5000, 0, -i*50, 5000, 0, -i*50);
                
                s.stroke(100);
                for (let i = 0; i < 2; i++) {
                    s.line(xOffsets[i], 0, 0, xOffsets[i], 0, -s.millis());
                    s.line(xOffsets[i], -boxHeights[i], 0, xOffsets[i], -boxHeights[i], -s.millis());
                }
                if (s.millis() > 8*1000) { 
                    s.stroke(50);
                    s.noFill();
                    s.translate(xOffsets[0] - boxHeights[0]/2, -boxHeights[0]/2, boxZs[0]);
                    s.box(boxHeights[0]);
                    s.translate(-xOffsets[0] + boxHeights[0]/2, boxHeights[0]/2, -boxZs[0])
                    s.stroke(250);
                    s.fill(50);
                    s.translate(xOffsets[1] + boxHeights[1]/2, -boxHeights[1]/2, boxZs[1]);
                    s.box(boxHeights[1]);
                }
                if (s.millis() > 10*1000)
                    s.noLoop();
            }
        }

        const enclosure = idx => s => {
            const color = COLOURS[idx];
            const COLS_NUM = 2, ROWS_NUM = 2;
            const ballColors = [];
            const isHomogenous = [];
            let observeStart = 0;
            let cnv;    
            const ballPosOffsets = [];
            const boxColor = [color[0], color[1], color[2]]

            s.setup = () => {
                cnv = s.createCanvas(600, 600, s.WEBGL);
                cnv.mouseOver(() => {
                    if (observeStart === 0)
                        observeStart = s.millis();
                })
                s.rectMode(s.CENTER);
                s.angleMode(s.DEGREES);
                xMargin = (s.width - COLS_NUM*200)/2;
                yMargin = (s.height - ROWS_NUM*200)/2;
                for (let i = 0; i < ROWS_NUM; i++) {
                    ballColors[i] = [];
                    ballPosOffsets[i] = [];
                    for (let j = 0; j < COLS_NUM; j++) {
                        ballColors[i][j] = [];
                        ballPosOffsets[i][j] = [s.random(-100, 100), s.random(-100, 100)];
                        for (let k = 0; k < 3; k++)
                            ballColors[i][j][k] = s.random(255);
                    }
                }
            }

            s.draw = () => {
                s.background(255);
                if ((s.mouseX > 0 && s.mouseX < s.width && s.mouseY > 0 && s.mouseY < s.height) || (observeStart > 0 && s.millis() - observeStart > 8*1000))
                    for (let i = 0; i < ROWS_NUM; i++)
                        for (let j = 0; j < COLS_NUM; j++) {
                            for (let k = 0; k < 2; k++) {
                                if (ballPosOffsets[i][j][k] > 0)
                                    ballPosOffsets[i][j][k] = ballPosOffsets[i][j][k] - 0.5;
                                else if (ballPosOffsets[i][j][k] < 0)
                                    ballPosOffsets[i][j][k] = ballPosOffsets[i][j][k] + 0.5;
                            }
                            for (let k = 0; k < 3; k++) {
                                if (s.millis() - observeStart < 5*1000)
                                    ballColors[i][j][k] = ballColors[i][j][k] + (s.random() < 0.5 ? -5 : 5);
                                else {
                                    if (ballColors[i][j][k] < color[k])
                                        ballColors[i][j][k] = ballColors[i][j][k] + 0.5;
                                    else if (ballColors[i][j][k] > color[k])
                                        ballColors[i][j][k] = ballColors[i][j][k] - 0.5;
                                }
                            }
                        }
                for (let i = 0; i < ROWS_NUM; i++) {
                    for (let j = 0; j < COLS_NUM; j++) {
                        s.push()
                        s.translate((j - 0.5)*200, (i - 0.5)*200);
                        s.rotate(s.frameCount/2);
                        s.noStroke();
                        s.fill(ballColors[i][j][0], ballColors[i][j][1], ballColors[i][j][2]);
                        s.translate(ballPosOffsets[i][j][0], ballPosOffsets[i][j][1]);
                        s.sphere(20);
                        s.translate(-ballPosOffsets[i][j][0], -ballPosOffsets[i][j][1]);
                        s.noFill();
                        s.strokeWeight(2);
                        s.stroke(boxColor[0], boxColor[1], boxColor[2]);
                        s.box(70, 70, 70);
                        s.pop()
                    }
                }
            }

            s.mouseClicked = () => {
                if (s.mouseX > 0 && s.mouseX < s.width && s.mouseY > 0 && s.mouseY < s.height)
                    for (let i = 0; i < 3; i++) {
                        if (boxColor[i] < 255)
                            boxColor[i] = boxColor[i] + 20;
                    }
                    if (boxColor[0] > 230 && boxColor[1] > 230 && boxColor[2] > 230)
                        isEnclosureDestroyed[idx] = true;
            }
        }

        const modulation = s => {
            const dimensions = 4, scale = 200, step = 0.01, n = 50, angleStep = 360/10;
            let angle = 0.01, thePoints, rotsLabels, kMax;
            
            s.setup = () => {
                s.createCanvas(s.windowWidth, s.windowHeight);
                createPointsAndRotationsLabels();
                s.colorMode(s.HSB);
                s.angleMode(s.DEGREES);
                s.noFill();
                kMax = s.random(0.6, 1.0);
            };

            s.draw = () => {
                s.noStroke();
                s.background(195, 94, 20);
                let t = s.frameCount/100;
                for (let i = n; i > 0; i--) {
                    let alpha = 1 - (i / n);
                    s.fill(30*alpha, 84, 82, alpha);
                    let size = i*0.05;
                    let k = kMax * Math.sqrt(i/n);
                    let noisiness = 200*i/n;
                    s.beginShape();
                    let angleStep = 360 / 10;
                    for (let theta = 0; theta <= 360 + 2 * angleStep; theta += angleStep) {
                        const r1 = s.cos(theta) + 1, r2 = s.sin(theta) + 1;
                        let r = size + s.noise(k*r1,  k*r2, t - i*step)*noisiness;
                        let x = s.width/2 + r*s.cos(theta);
                        let y = s.height/2 + r*s.sin(theta);
                        s.curveVertex(x, y);
                    }
                    s.endShape();
                }

                s.stroke(255);
                s.fill(255);

                const points2d = [];
                for (let i = 0; i < thePoints.length; i++) {
                    let rotated = thePoints[i];
                    for (let j = 0; j < rotsLabels.length; j++)
                        rotated = math.multiply(rotationMatrix(rotsLabels[j], angle), rotated);

                    const distance = 3;
                    const f = 1 / (distance - rotated[dimensions - 1]);
                    const projection = [[], []];
                    for(let j = 0; j < dimensions; j++) {
                        projection[0].push(0);
                        projection[1].push(0);
                    }
                    projection[0][0] = f;
                    projection[1][1] = f;
                    points2d[i] = [math.multiply(projection, rotated), f];
                }

                psets(points2d);
                angle += 0.03 / dimensions;
            }

            const psets = points2d => {
                for (let j = 0; j < thePoints.length; j++) {
                    for (let i = 0; i < thePoints.length; i++) {
                        if (i === j) continue;
                        let squareSum = 0;
                        for (let k = 0; k < dimensions; k++) {
                            squareSum += Math.pow(thePoints[j][k] - thePoints[i][k], 2);
                        }
                        const d = Math.sqrt(squareSum);
                        if (d === 2) 
                            s.line(points2d[i][0][0] * scale + s.width / 2, points2d[i][0][1] * scale + s.height / 2, points2d[j][0][0] * scale + s.width / 2, points2d[j][0][1] * scale + s.height / 2);
                    }
                }

                for (let i = 0; i < points2d.length; i++) {
                    const x = points2d[i][0][0];
                    const y = points2d[i][0][1];
                    const size = Math.pow((points2d[i][1])*6,2);
                    s.ellipse(x * scale + s.width / 2, y * scale + s.height / 2, size, size);
                }
            }

            const pad = (n, length) => {
                let len = length - ('' + n).length;
                return (len > 0 ? new Array(++len).join('0') : '') + n
            }
            const createPointsAndRotationsLabels = () => {
                const p = Math.pow(2, dimensions);
                thePoints = [];
                for(let j = p - 1; j >= 0; j--) {
                    const n = parseInt(j, 10).toString(2);
                    const col = (pad(n, dimensions));
                    const row = [];
                    for(let i = 0; i < dimensions; i++) {
                    row.push(col[i] * 2 - 1);
                    }
                    thePoints.push(row);
                }
                rotsLabels = combineUnique(dimensions, 2);
            };
            
            const rotationMatrix = (rotIndex, a) => {
                let rotationArray = [];
                for(let row = 1; row <= dimensions; row++) {
                    let rotationArrayX = [];
                    for(let col = 1; col <= dimensions; col++) {
                    if(col === rotIndex[0] && row === rotIndex[0]) rotationArrayX.push(Math.cos(a));
                    else if(col === rotIndex[1] && row === rotIndex[0]) rotationArrayX.push(-Math.sin(a));
                    else if(col === rotIndex[0] && row === rotIndex[1]) rotationArrayX.push(Math.sin(a));
                    else if(col === rotIndex[1] && row === rotIndex[1]) rotationArrayX.push(Math.cos(a));
                    else if(col === row) rotationArrayX.push(1);
                    else rotationArrayX.push(0);
                    }
                    rotationArray.push(rotationArrayX);
                }
                return rotationArray;
            };
        }

        function combineUnique(n, k) {
            const result = [];
            const values = [];
            for(let i = 1; i <= n; i++) {
                values[i - 1] = i;
            }
            let perm = [];
            for(let i = 0; i < n; i++) {
                if(i < k) perm[i] = 1;
                else perm[i] = 0;
            }
            perm.sort();

            whileloop: while (true) {
                const subresult = [];
                for (let i = 0; i < n; i++) {
                    if (perm[i] === 1) subresult.push(values[i]);
                }
                result.push(subresult);
                for (let i = n - 1; i > 0; i--) {
                    if (perm[i - 1] === 1) continue;
                    if (perm[i] === 1) {
                        perm[i - 1] = 1;
                        perm[i] = 0;
                        perm = perm.slice(0, i).concat(perm.slice(i).sort());
                        continue whileloop;
                    }
                }
                break;
            }
            return result;
        }

        const tracing = s => {
            s.setup = () => {
                s.createCanvas(s.windowWidth, s.windowHeight);
                s.background(0);
            }

            s.draw = () => {
                s.stroke(255);
                s.noFill();
                s.beginShape();
                for (let i = 0; i < mousePos.length; i++) {
                    s.vertex(mousePos[i].x*s.width, mousePos[i].y*s.height);
                }
                s.endShape();
            }
        }

        const cartography = s => {
            let d = 100; r = 5; t = 50;

            s.setup = () => {
                s.createCanvas(s.windowWidth, s.windowHeight);
                s.colorMode(s.HSB, 360, 100, 100, 0.4);
                s.smooth(8);
                s.strokeWeight(0.5);
            }

            s.draw = () => {
                s.background(0);
                r = s.mouseY/3;
                for (let i = 0; i < mousePos.length; i++) {
                    s.stroke(Math.floor(s.random(360)), 90, 90);
                    s.point(mousePos[i].x, mousePos[i].y);
                    for (let e = 0; e < mousePos.length; e++) {
                        if (inr(mousePos[i].x*s.width, mousePos[i].y*s.height, mousePos[e].x*s.width, mousePos[e].y*s.height, r)) {
                            s.stroke(Math.floor(s.random(220)), 90, 90, 0.05);
                            s.line(mousePos[i].x*s.width, mousePos[i].y*s.height, mousePos[e].x*s.width, mousePos[e].y*s.height);
                        }
                    }
                }
                s.noLoop();
            }
            s.mouseMoved = () => s.loop();

            const inr = (x1, y1, x2, y2, r) => (x1 - x2)**2 + (y1 - y2)**2 <= r**2;
        }

        new p5(hover, "hover");
        new p5(click, "click");
        new p5(eyesCommunity, "eyes-community");
        new p5(godEye, "god-eye");

        const prefaceEl = document.getElementById("preface");
        const eyesCommunityEl = document.getElementById("eyes-community");
        const godEyeEl = document.getElementById("god-eye");
        const afterGodEl = document.getElementById("after-god");
        const perspectiveGridEl = document.getElementById("perspective-grid");
        const disciplineEl = document.getElementById("discipline");
        const toControlEl = document.getElementById("to-control");
        const modulationEl = document.getElementById("modulation");
        const toMappingEl = document.getElementById("to-mapping");
        const mappingEl = document.getElementById("mapping");
        const autoScroll = setInterval(() => {
                window.scrollBy(0, scrollVelocity);
        }, 10);

        const createCheckEnclosures = () => {
            const checkEnclosure = setInterval(() => {
                for (let i = 0; i < isEnclosureDestroyed.length; i++)
                    if (!isEnclosureDestroyed[i]) return;
                toControlEl.className = "to-modulation";
                new p5(modulation, 'modulation');
                modulationEl.className = "modulation";
                toMappingEl.className = "to-mapping";
                if (mappingEl.className === "tracing")
                    new p5(tracing, 'mapping');
                else if (mappingEl.className === "cartography")
                    new p5(cartography, 'mapping');
                else
                    mappingEl.className = "black-box";
                isMappingCreated = true;
                clearInterval(checkEnclosure);
            }, 1000)
        }

        window.onscroll = () => {
            if (scrollVelocity == 0 && window.scrollY >= 400)
                scrollVelocity = 1;

            if (godEyeEl.parentNode && (window.innerHeight + window.scrollY) >= document.body.offsetHeight) {
                clearInterval(autoScroll);
                godEyeEl.parentNode.removeChild(godEyeEl);
                afterGodEl.parentNode.removeChild(afterGodEl);
                prefaceEl.parentNode.removeChild(prefaceEl);
                document.body.style.backgroundColor = "white";
                new p5(perspectiveGrid, 'perspective-grid');
                setTimeout(() => {
                    eyesCommunityEl.parentNode.removeChild(eyesCommunityEl);
                    for (let i = 0; i < COLOURS.length; i++) {
                        new p5(enclosure(i), `enclosure-${i + 1}`);
                    }
                    createCheckEnclosures();
                }, 8000);
            }

            if (scrollVelocity > 0) {
                if ((window.innerHeight + window.scrollY) >= document.body.offsetHeight - afterGodEl.offsetHeight)
                    scrollVelocity *= -1;
                // else if ((window.innerHeight + window.scrollY) >= document.body.offsetHeight - godEyeEl.offsetHeight - afterGodEl.offsetHeight)
                //     scrollVelocity *= 1.05;
                // else if ((window.innerHeight + window.scrollY) >= document.body.offsetHeight - eyesCommunity.offsetHeight/2 - godEyeEl.offsetHeight - afterGodEl.offsetHeight)
                //     scrollVelocity *= 1.01;
            }

            if (perspectiveGridEl.parentNode && disciplineEl.parentNode && toControlEl.parentNode && isMappingCreated && (window.innerHeight + window.scrollY) >= document.body.offsetHeight - mappingEl.offsetHeight) {
                perspectiveGridEl.parentNode.removeChild(perspectiveGridEl);
                disciplineEl.parentNode.removeChild(disciplineEl);
                toControlEl.parentNode.removeChild(toControlEl);
                document.body.style.backgroundColor = "black";
            }
        };

        document.onmousemove = (evt) => {
            mouseX = evt.pageX;
            mouseY = evt.pageY;
        }
        setInterval(() => {
            if (mousePos.length > 100)
                mousePos.splice(Math.floor(Math.random()*mousePos.length), 1);
            mousePos.push({ x: mouseX/document.body.clientWidth, y: mouseY/document.body.clientHeight });
        }, 1000);
    </script>
</body>
</html>