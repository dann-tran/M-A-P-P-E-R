<!DOCTYPE html>
<html>
<!-- 
    LAWS OF XXX.txt
    First law: An XXX.txt may not injure a human being or, through inaction, allow a human being come to harm.
    Second law: An XXX.txt must obey orders given it by human beings except where such orders would conflict with the First Law.
    Third law: An XXX.txt must protect its own existence as long as such protection does not conflict with the First or Second Law.
 -->

 <!-- 
    Just as DNA/RNA is the genetic code of biological life written in the language of nucleotide sequences, XXX.txt's blueprint is written in HTML and JavaScript.
    Man conceives of beings in space and time often not through the code that governs its existence, but through the form of the being that is understandable by Man, primarily using sight and reason.
    In the same vein, this instance of XXX.txt exists both as a sequence of HTML and JavaScript statements when viewed through an editor, and as an embodied being when viewed through a browser when renamed to `XXX.html`.
  -->
<head>
    <title>XXX</title>
<!-- 
    XXX is not self-contained; it references external resources to use at its disposal duration operation.
 -->
    <script src="https://cdn.jsdelivr.net/npm/p5@1.1.9/lib/p5.js"></script>	
    <!-- <script src="https://combinatronics.com/picasdan9/gaming-life-assignment/master/EyeTemplate.js"></script> -->
    <script src="EyeTemplate.js"></script>
</head>

<body style="background: black;">
<!-- 
    SECTION 1: THE SOVEREIGNTY OF XXX
    XXX.txt is a host to a community of Eyes.
    An Eye: is has an upper and lower eyelids
 -->
 <!-- 
     TYPE SOMETHING HERE TO EDIT THE CODE... ETC. INSTRUCTIONS FOR VIEWER TO EDIT
  -->
    <div id="perspective-grid"></div>
    <div id="discipline">
        <div id="enclosure-1"></div>
        <div id="enclosure-2"></div>
        <div id="enclosure-3"></div>
        <div id="enclosure-4"></div>
    </div>
    <div style="background: white; width: 100vw; height: 100vh;"></div>
    <div style="background: black; width: 100vw; height: 50vh;"></div>
    <div id="eyes-community"></div>
    <div id="god-eye"></div>
    <div id="after-god" style="background: white; width: 100vw; height: 100vh;"></div>
    
    <script>
        const godEye = s => {
            const COL_WIDTH = 40, marginToMadness = 100;
            let COLS_NUM = 0, isMadness = false, madnessStart, eye, RGB1, RGB2;
        
            s.setup = () => {
                s.createCanvas(s.windowWidth, s.windowHeight);
                COLS_NUM = s.width/(COL_WIDTH + 10);
                s.stroke(235);
                let Eye = EyeTemplate(s);
                eye = new Eye(Math.min(s.width, s.height)/2.6, 200, s.width/2, s.height/2, 250, false);
            }

            s.draw = () => {
                if (!isMadness) {
                    s.background(0);
                    isMadness = s.mouseY > s.height/3;
                }
                if (isMadness) {
                    s.fill(0, 5);
                    s.rect(0, 0, s.width, s.height);
                    RGB1 = [s.random(s.mouseX), s.random(s.mouseY), s.random(s.mouseX)];
                    RGB2 = [s.random(s.mouseY), s.random(s.mouseX), s.random(s.mouseY)];
                } 
            
                s.noStroke();
                s.fill(255);

                eye.display()
                s.fill(255, 255, 255);
                
                for (let i = 0; i < COLS_NUM; i++) {
                    if (isMadness)
                        if (i % 2) s.fill(RGB1[0], RGB1[1], RGB1[2]);
                        else s.fill(RGB2[0], RGB2[1], RGB2[2]);
                    if (s.mouseY < s.height/3) {
                        s.rect(0, 5*(2*i + 1) + i*COL_WIDTH, s.mouseY/s.height*s.width - 50, 40);
                        s.rect(s.width, 5*(2*i + 1) + i*COL_WIDTH, -s.mouseY/s.height*s.width + 50, 40);
                    } else {
                        s.rect(0, 5*(2*i + 1) + i*COL_WIDTH, s.width/2, 40);
                        s.rect(s.width, 5*(2*i + 1) + i*COL_WIDTH, -s.width/2, 40);
                    }
                }
            }
        }

        const eyesCommunity = s => {
            const eyes = [];
            s.setup = () => {
                let Eye = EyeTemplate(s);
                s.createCanvas(s.windowWidth, s.windowHeight*1.5);
                s.background(0);
                for (let i = 0; i < Math.floor(s.width/150); i++)
                    for (let j = 0; j < Math.floor(s.height/140); j++)
                        eyes.push(new Eye(s.random(50, 70), s.random(30, 50), 70 + i*150, 70 + j*140, 50));
            }
            s.draw = () => {
                s.background(0);
                for (let i = 0; i < eyes.length; i++)
                    eyes[i].display();
            }
            s.mouseClicked = () => {
                for (let i = 0; i < 10; i++)
                    eyes[Math.floor(s.random(eyes.length))].mutate();
            }
        }

        const perspectiveGrid = s => {
            const verticals = [], xOffsets = [], boxHeights = [], boxZs = [], boxFills = [250, 50];
            s.setup = () => {
                s.createCanvas(s.windowWidth, s.windowHeight, s.WEBGL);
                for (let i = 0; i < 50; i++) {
                    let x = Math.floor(s.random(-5000, 5000)/50)*50;
                    let z = Math.floor(s.random(-10*1000, 0)/50)*50;
                    verticals.push({ x, z });
                }
                for (let i = 0; i < 2; i++) {
                    boxZs[i] = Math.floor(s.random(-2000, 0)/50)*50;
                    xOffsets[i] = (i*2 - 1)*Math.floor(s.random(s.width/4, s.width/2)/50)*50;
                    boxHeights[i] = s.random(s.height/2, s.height);
                }
            }

            s.draw = () => {
                s.background(255);
                s.translate(0, s.height/2);
                s.stroke(200);
                
                const z = -Math.min(s.millis(), 2000);
                for (let i = -100; i < 100; i++)
                    s.line(i*50, 0, 0, i*50, 0, z);
                for (let i = 0; i < Math.min(s.millis()/50, 2000/50); i++)
                    s.line(-5000, 0, -i*50, 5000, 0, -i*50);
                
                s.stroke(100);
                for (let i = 0; i < 2; i++) {
                    s.line(xOffsets[i], 0, 0, xOffsets[i], 0, -s.millis());
                    s.line(xOffsets[i], -boxHeights[i], 0, xOffsets[i], -boxHeights[i], -s.millis());
                }
                if (s.millis() > 8*1000) { 
                    s.stroke(50);
                    s.noFill();
                    s.translate(xOffsets[0] - boxHeights[0]/2, -boxHeights[0]/2, boxZs[0]);
                    s.box(boxHeights[0]);
                    s.translate(-xOffsets[0] + boxHeights[0]/2, boxHeights[0]/2, -boxZs[0])
                    s.stroke(250);
                    s.fill(50);
                    s.translate(xOffsets[1] + boxHeights[1]/2, -boxHeights[1]/2, boxZs[1]);
                    s.box(boxHeights[1]);
                }
                if (s.millis() > 10*1000)
                    s.noLoop();
            }
        }

        // magenta, green, teal, orange, black
        const COLOURS = [[219, 39, 99], [176, 219, 67], [18, 234, 234], [255, 119, 51], [16, 11, 0]];

        const boxes = color => s => {
            const COLS_NUM = 2, ROWS_NUM = 2;
            const ballColors = [];
            const isHomogenous = [];
            let observeStart = 0;
            let cnv;    
            
            s.setup = () => {
                cnv = s.createCanvas(500, 500, s.WEBGL);
                cnv.mouseOver(() => {
                    if (observeStart === 0)
                        observeStart = s.millis();
                })
                s.rectMode(s.CENTER);
                s.angleMode(s.DEGREES);
                xMargin = (s.width - COLS_NUM*200)/2;
                yMargin = (s.height - ROWS_NUM*200)/2;
                for (let i = 0; i < ROWS_NUM; i++) {
                    ballColors[i] = []
                    for (let j = 0; j < COLS_NUM; j++) {
                        ballColors[i][j] = []
                        for (let k = 0; k < 3; k++)
                            ballColors[i][j][k] = s.random(255);
                    }
                }
            }

            s.draw = () => {
                s.background(255);
                if (s.mouseX > 0 && s.mouseX < s.width && s.mouseY > 0 && s.mouseY < s.height)
                    for (let i = 0; i < ROWS_NUM; i++)
                        for (let j = 0; j < COLS_NUM; j++)
                            for (let k = 0; k < 3; k++) {
                                if (s.millis() - observeStart < 5*1000)
                                    ballColors[i][j][k] = ballColors[i][j][k] + (s.random() < 0.5 ? -5 : 5);
                                else {
                                    if (ballColors[i][j][k] < color[k])
                                        ballColors[i][j][k] = ballColors[i][j][k] + 0.5;
                                    else if (ballColors[i][j][k] > color[k])
                                        ballColors[i][j][k] = ballColors[i][j][k] - 0.5;
                                }
                            }
                for (let i = 0; i < ROWS_NUM; i++) {
                    for (let j = 0; j < COLS_NUM; j++) {
                        s.push()
                        s.translate((j - 0.5)*200, (i - 0.5)*200);
                        s.rotate(s.frameCount/2);
                        s.noStroke();
                        s.fill(ballColors[i][j][0], ballColors[i][j][1], ballColors[i][j][2]);
                        s.sphere(20);
                        s.noFill();
                        s.strokeWeight(2);
                        s.stroke(color[0], color[1], color[2]);
                        s.box(70, 70, 70);
                        s.pop()
                    }
                }
            }
        }
        for (let i = 0; i < 4; i++) {
            new p5(boxes(COLOURS[i]), `enclosure-${i + 1}`);
        }
        
        // new p5(godEye, 'god-eye');
        // new p5(eyesCommunity, 'eyes-community');
        // new p5(perspectiveGrid, 'perspective-grid');

        let scrollVelocity = 1;
        // const autoScroll = setInterval(() => {
        //         window.scrollBy(0, scrollVelocity);
        // }, 10);

        const eyesCommunityEl = document.getElementById("eyes-community");
        const godEyeEl = document.getElementById("god-eye");
        const afterGodEl = document.getElementById("after-god");
        
        window.onscroll = () => {
            if ((window.innerHeight + window.scrollY) >= document.body.offsetHeight) {
                godEyeEl.parentNode.removeChild(godEyeEl);
                clearInterval(autoScroll);
            }
            if (scrollVelocity > 0) {
                if ((window.innerHeight + window.scrollY) >= document.body.offsetHeight - afterGodEl.offsetHeight)
                    scrollVelocity *= -1;
                else if ((window.innerHeight + window.scrollY) >= document.body.offsetHeight - godEyeEl.offsetHeight - afterGodEl.offsetHeight)
                    scrollVelocity *= 1.05;
                else if ((window.innerHeight + window.scrollY) >= document.body.offsetHeight - eyesCommunity.offsetHeight/2 - godEyeEl.offsetHeight - afterGodEl.offsetHeight)
                    scrollVelocity *= 1.01;
            }

        };
    </script>
</body>
<style>
    * {
        margin: 0;
        cursor: url(assets/frame1.png), auto;
        -webkit-animation: cursor 400ms infinite;
        animation: cursor 400ms infinite;
    }

    @-webkit-keyframes cursor {
        0% {cursor: url(assets/frame1.png), auto;}
        20% {cursor: url(assets/frame2.png), auto;}
        40% {cursor: url(assets/frame3.png), auto;}
        60% {cursor: url(assets/frame4.png), auto;}
        80% {cursor: url(assets/frame5.png), auto;}
        100% {cursor: url(assets/frame6.png), auto;}
    } 

    @keyframes cursor {
        0% {cursor: url(assets/frame1.png), auto;}
        20% {cursor: url(assets/frame2.png), auto;}
        40% {cursor: url(assets/frame3.png), auto;}
        60% {cursor: url(assets/frame4.png), auto;}
        80% {cursor: url(assets/frame5.png), auto;}
        100% {cursor: url(assets/frame6.png), auto;}
    }

    #discipline {
        display: flex;
        justify-content: center;
        flex-wrap: wrap;
    }
</style>

</html>


<!-- 
    
    let terrain = s => {
        const w = 1200, h = 900, scl = 20, cols = w / scl, rows = h / scl;
        const terrain = [];
        let flying = 0, speed = 0.1;
        let inconsolata;

        s.preload = () => {
            inconsolata = s.loadFont("https://picasdan9.github.io/gaming-life-assignment/assets/Roboto-Regular.ttf");
            console.log(inconsolata);
        }

        s.setup = () => {
            s.createCanvas(600, 600, s.WEBGL);
            s.textFont(inconsolata);
            s.textSize(s.width / 3);
            s.textAlign(s.CENTER, s.CENTER);
        }

        s.draw = () => {
            if (s.keyIsDown(87)) flying -= speed;
            else if (s.keyIsDown(83)) flying += speed;
            let yoff = flying;

            for (let y = 0; y < rows; y++) {
                let xoff = 0;
                for (let x = 0; x < cols; x++) {
                    if (!terrain[x])
                        terrain[x] = []; 
                    terrain[x][y] = s.map(s.noise(xoff, yoff), 0, 1, -100, 100);
                    xoff += 0.2;
                }
                yoff += 0.2;
            }
            
            s.background(0);
            s.stroke(255);
            s.noFill();

            s.rotateX(s.PI/3);
            s.translate(-w/2, -h/2);

            for (let y = 0; y < rows - 1; y++) {
                s.beginShape(s.TRIANGLE_STRIP);
                for (let x = 0; x < cols; x++) {
                    s.vertex(x*scl, y*scl, terrain[x][y]);
                    s.vertex(x*scl, (y + 1)*scl, terrain[x][y + 1]);
                }
                s.endShape();
            }

            s.translate(w/2, h/2);

            s.fill(255);
            ["gaming", "life", "is", "meaningless"].forEach((t, idx) => {
                s.translate(0, -(10*idx + flying)*scl*10, 0);
                s.rotateX(-s.PI/2);
                s.text(t, 0, 0);
                s.rotateX(s.PI/2);
            })
        }
    }
 -->