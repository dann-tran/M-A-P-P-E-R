<!-- 
    LAWS OF XXX
    First law: An XXX may not injure a human being or, through inaction, allow a human being come to harm.
    Second law: An XXX must obey orders given it by human beings except where such orders would conflict with the First Law.
    Third law: An XXX must protect its own existence as long as such protection does not conflict with the First or Second Law.
 -->

<!DOCTYPE html>
<html>

<head>
	<meta charset="UTF-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Gaming life</title>
    <script src="https://cdn.jsdelivr.net/npm/p5@1.1.9/lib/p5.js"></script>	

</head>

<body>
    <main>
        <div id="page-wrapper">
            <h3>Gaming life</h3>
        </div>
        <div id="container" />
    </main>
    <script>
    let terrain = s => {
        const w = 1200, h = 900, scl = 20, cols = w / scl, rows = h / scl;
        const terrain = [];
        let flying = 0, speed = 0.1;
        let inconsolata;

        s.preload = () => {
            inconsolata = s.loadFont("https://picasdan9.github.io/gaming-life-assignment/Roboto-Regular.ttf");
            console.log(inconsolata);
        }

        s.setup = () => {
            s.createCanvas(600, 600, s.WEBGL);
            s.textFont(inconsolata);
            s.textSize(s.width / 3);
            s.textAlign(s.CENTER, s.CENTER);
        }

        s.draw = () => {
            if (s.keyIsDown(87)) flying -= speed;
            else if (s.keyIsDown(83)) flying += speed;
            let yoff = flying;

            for (let y = 0; y < rows; y++) {
                let xoff = 0;
                for (let x = 0; x < cols; x++) {
                    if (!terrain[x])
                        terrain[x] = []; 
                    terrain[x][y] = s.map(s.noise(xoff, yoff), 0, 1, -100, 100);
                    xoff += 0.2;
                }
                yoff += 0.2;
            }
            
            s.background(0);
            s.stroke(255);
            s.noFill();

            s.rotateX(s.PI/3);
            s.translate(-w/2, -h/2);

            for (let y = 0; y < rows - 1; y++) {
                s.beginShape(s.TRIANGLE_STRIP);
                for (let x = 0; x < cols; x++) {
                    s.vertex(x*scl, y*scl, terrain[x][y]);
                    s.vertex(x*scl, (y + 1)*scl, terrain[x][y + 1]);
                }
                s.endShape();
            }

            s.translate(w/2, h/2);

            s.fill(255);
            ["gaming", "life", "is", "meaningless"].forEach((t, idx) => {
                s.translate(0, -(10*idx + flying)*scl*10, 0);
                s.rotateX(-s.PI/2);
                s.text(t, 0, 0);
                s.rotateX(s.PI/2);
            })
        }
    }

    let epilepsy = s => {
        let COLOR = 220;
        const widths = [20, 80,  140, 200, 260, 320, 380,  440], heights = [80, 40, 10, 0, 0, 10, 40, 80];
    
        s.setup = () => {
            s.createCanvas(500, 500);
            s.stroke(235);
        }

        s.draw = () => {
            s.background(40);
            s.fill(COLOR, 50, 0);
            s.noStroke();
            s.ellipse(s.width/2, s.height/2, s.width/1.3, s.height/1.3);
            s.fill(COLOR, COLOR, COLOR);
            for (let i = 0; i < widths.length; i++) {
                s.rect(widths[i], 20, 40, Math.max(s.mouseY + heights[i], 0));
                s.rect(widths[i], 480, 40, Math.min(-s.mouseY - heights[i], 0));
            }
            if (s.mouseY > 100 && s.mouseY < 250) {
                s.fill(255);
                s.ellipse(250, 250, 100, 100);
                s.fill(20);
                s.ellipse(250, 250, 60, 60);
            }
            if (s.mouseY > 250) COLOR = s.random(255)
            else COLOR = 220;
        }
    }

    let eyes = s => {
        let phase = 0;
        const phaseDelta = 1/120, eyes = [];

        class Eye {
            constructor(x, y, r1, r2) {
                this.x = x;
                this.y = y;
                this.r1 = r1;
                this.r2 = r2;
                this.vx = x;
                this.vy = y;
            }

            // constructor(scale, nodeAmount, xMovement, yMovement) {
            //     this.xPos1 = (s.width/2 - scale) + xMovement;
            //     this.yPos1 = s.height/2 + yMovement;
            //     this.xNode1 = (s.width/2 - nodeAmount) + xMovement;
            //     this.yNode2 = (s.height/2 - nodeAmount) + yMovement;
            //     this.
            // }

            draw() {
                s.fill(255);
                s.stroke(0);
                s.ellipse(this.x, this.y, this.r1*2, this.r1*2);
                s.push();
                s.fill(255, 0, 0);
                s.noStroke();
                const a = s.atan2(s.mouseY - this.y, s.mouseX - this.x);
                let x2 = this.x + (this.r1 - this.r2)*s.cos(a);
                let y2 = this.y + (this.r1 - this.r2)*s.sin(a);
                if (s.dist(this.x, this.y, s.mouseX, s.mouseY) < this.r1 - this.r2) {
                    x2 = s.mouseX;
                    y2 = s.mouseY;
                }
                this.vx = s.lerp(this.vx, x2, 0.05);
                this.vy = s.lerp(this.vy, y2, 0.05);
                s.ellipse(this.vx, this.vy, this.r2*2, this.r2*2);
                s.pop();
            }
        }
        s.setup = () => {
            s.createCanvas(500, 500);
            let i = 0;
            while (i < 20) {
                let r1 = s.random(10, 50);
                let r2 = r1 * s.random(0.3, 0.6);
                let x = s.random(r1, s.width - r1);
                let y = s.random(r1, s.height - r1);
                if (i == 0) {
                    eyes[i] = new Eye(x, y, r1, r2);
                    i++;
                } else {
                    let overlap = false;
                    for (let j = 0; j < eyes.length; j++) {
                        const e = eyes[j];
                        const d = s.dist(x, y, e.x, e.y);
                        if (d < r1 + e.r1) {
                            overlap = true;
                            break;
                        }
                    }
                    if (!overlap) {
                        eyes[i] = new Eye(x, y, r1, r2);
                        i++;
                    }
                }
            }
        }
        s.draw = () => {
            s.background(0);
            const a = s.TWO_PI*phase;
            phase += phaseDelta;
            if (phase >= 1) phase -= 1;
            eyes.forEach(e => e.draw());
        }
    }
    new p5(eyes, 'container');
    </script>
</body>


</html>