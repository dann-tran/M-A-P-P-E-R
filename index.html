<!DOCTYPE html>
<html>
<!-- 
    LAWS OF XXX.txt
    First law: An XXX.txt may not injure a human being or, through inaction, allow a human being come to harm.
    Second law: An XXX.txt must obey orders given it by human beings except where such orders would conflict with the First Law.
    Third law: An XXX.txt must protect its own existence as long as such protection does not conflict with the First or Second Law.
 -->

 <!-- 
    Just as DNA/RNA is the code of biological life written in the language of nucleotide sequences, XXX.txt's blueprint is written in HTML and JavaScript, a programming language.
    Man conceives of beings in space and time often not through the code that governs its existence, but through the form of the being that is understandable by Man, primarily using sight and reason.
    In the same vein, this instance of XXX.txt exists both as a sequence of HTML and JavaScript statements when viewed through an editor, and as an embodied being when viewed through a browser when renamed to `XXX.html`.
  -->
<head>
    <title>XXX</title>
<!-- 
    XXX is not self-contained; it references external resources to use at its disposal duration operation.
 -->
    <script src="https://cdn.jsdelivr.net/npm/p5@1.1.9/lib/p5.js"></script>	
    <script src="https://combinatronics.com/picasdan9/gaming-life-assignment/master/EyeTemplate.js"></script>
</head>

<body style="background: black;">
<!-- 
    SECTION 1: THE SOVEREIGNTY OF XXX
    XXX.txt is a host to a community of Eyes.
 -->
    <div id="eyes-community"></div>
    <div id="god-eye"></div>
    
    <script>
        const godEye = s => {
            const COL_WIDTH = 40;
            let COLS_NUM = 0, isMadness = false, madnessStart, eye, RGB1, RGB2;
        
            s.setup = () => {
                s.createCanvas(s.windowWidth, s.windowHeight);
                COLS_NUM = s.width/(COL_WIDTH + 10);
                s.stroke(235);
                let Eye = EyeTemplate(s);
                eye = new Eye(Math.min(s.width, s.height)/2.6, 200, s.width/2, s.height/2, 250, false);
            }

            s.draw = () => {
                if (!isMadness) {
                    s.background(0);
                    isMadness = s.mouseY > s.height/2;
                }
                if (isMadness) {
                    s.fill(0, 5);
                    s.rect(0, 0, s.width, s.height);
                    RGB1 = [s.random(s.mouseX), s.random(s.mouseY), s.random(s.mouseX)];
                    RGB2 = [s.random(s.mouseY), s.random(s.mouseX), s.random(s.mouseY)];
                    if (s.millis() - madnessStart > 5000)
                    isMadnes = false;
                } 
            
                s.noStroke();
                s.fill(255);

                eye.display()
                s.fill(255, 255, 255);
                
                for (let i = 0; i < COLS_NUM; i++) {
                    if (isMadness)
                        if (i % 2) s.fill(RGB1[0], RGB1[1], RGB1[2]);
                        else s.fill(RGB2[0], RGB2[1], RGB2[2]);
                    s.rect(5*(2*i + 1) + i*COL_WIDTH, 0, 40, s.mouseY - 50, 0);
                    s.rect(5*(2*i + 1) + i*COL_WIDTH, s.height, 40, -s.mouseY + 50, 0);
                }   
            }
        }

        const eyesCommunity = s => {
            const eyes = [];
            s.setup = () => {
                let Eye = EyeTemplate(s);
                s.createCanvas(s.windowWidth, 2040);
                s.background(0);
                for (let i = 0; i < Math.floor(s.width/150); i++)
                    for (let j = 0; j < Math.floor(s.height/140); j++)
                        eyes.push(new Eye(s.random(50, 70), s.random(30, 50), 70 + i*150, 70 + j*140, 50));
            }
            s.draw = () => {
                s.background(0);
                for (let i = 0; i < eyes.length; i++)
                    eyes[i].display();
            }
        }
        new p5(godEye, 'god-eye');
        new p5(eyesCommunity, 'eyes-community');
    </script>
</body>
<style>
    * {
        margin: 0;
    }
</style>

</html>


<!-- 
    
    let terrain = s => {
        const w = 1200, h = 900, scl = 20, cols = w / scl, rows = h / scl;
        const terrain = [];
        let flying = 0, speed = 0.1;
        let inconsolata;

        s.preload = () => {
            inconsolata = s.loadFont("https://picasdan9.github.io/gaming-life-assignment/Roboto-Regular.ttf");
            console.log(inconsolata);
        }

        s.setup = () => {
            s.createCanvas(600, 600, s.WEBGL);
            s.textFont(inconsolata);
            s.textSize(s.width / 3);
            s.textAlign(s.CENTER, s.CENTER);
        }

        s.draw = () => {
            if (s.keyIsDown(87)) flying -= speed;
            else if (s.keyIsDown(83)) flying += speed;
            let yoff = flying;

            for (let y = 0; y < rows; y++) {
                let xoff = 0;
                for (let x = 0; x < cols; x++) {
                    if (!terrain[x])
                        terrain[x] = []; 
                    terrain[x][y] = s.map(s.noise(xoff, yoff), 0, 1, -100, 100);
                    xoff += 0.2;
                }
                yoff += 0.2;
            }
            
            s.background(0);
            s.stroke(255);
            s.noFill();

            s.rotateX(s.PI/3);
            s.translate(-w/2, -h/2);

            for (let y = 0; y < rows - 1; y++) {
                s.beginShape(s.TRIANGLE_STRIP);
                for (let x = 0; x < cols; x++) {
                    s.vertex(x*scl, y*scl, terrain[x][y]);
                    s.vertex(x*scl, (y + 1)*scl, terrain[x][y + 1]);
                }
                s.endShape();
            }

            s.translate(w/2, h/2);

            s.fill(255);
            ["gaming", "life", "is", "meaningless"].forEach((t, idx) => {
                s.translate(0, -(10*idx + flying)*scl*10, 0);
                s.rotateX(-s.PI/2);
                s.text(t, 0, 0);
                s.rotateX(s.PI/2);
            })
        }
    }
 -->